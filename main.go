// Original code by @Omochice <https://github.com/Omochice/deepl-translate-cli>
// With some extra tweaks by Gwyneth Llewelyn <https://gwynethllewelyn.net>
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"runtime/debug"
	"time"

	"github.com/Omochice/deepl-translate-cli/deepl"
	"github.com/mattn/go-isatty"
	"github.com/urfave/cli/v2"
)

// versionInfoType holds the relevant information for this build.
// it is meant to be used as a cache.
type versionInfoType struct {
	version		string		// Runtime version.
	commit  	string		// Commit revision number.
	dateString 	string		// Commit revision time (as a RFC3339 string).
	date		time.Time	// Same as before, converted to a time.Time, because that's what the cli package uses.
	builtBy 	string		// User who built this (see note).
	goOS		string		// Operating system for this build (from runtime).
	goARCH		string		// Architecture, i.e., CPU type (from runtime)
	goVersion	string		// Go version used to compile this build (from runtime)
	init		bool		// Have we already initialised the cache object?
}

// NOTE: I don't know where the "builtBy" information comes from, so, right now, it gets injected
// during build time, e.g. `go build -ldflags "-X main.TheBuilder=gwyneth"` (gwyneth 20231103)

var (
	versionInfo versionInfoType	// cached values for this build.
	TheBuilder string			// to be overwritten via the linker command `go build -ldflags "-X main.TheBuilder=gwyneth"`.
)

// Initialises the versionInfo variable.
func initVersionInfo() error {
	if versionInfo.init {
		// already initialised, no need to do anything else!
		return nil
	}
	// get the following entries from the runtime:
	versionInfo.goOS		= runtime.GOOS
	versionInfo.goARCH		= runtime.GOARCH
	versionInfo.goVersion	= runtime.Version()

	// attempt to get some build info as well:
	buildInfo, ok := debug.ReadBuildInfo()
	if !ok {
		return fmt.Errorf("no valid build information found")
	}
	versionInfo.version = buildInfo.Main.Version

	// Now dig through settings and extract what we can...

	var vcs, rev string // Name of the version control system name (very likely Git) and the revision.
	for _, setting := range buildInfo.Settings {
		switch setting.Key {
			case "vcs":
				vcs = setting.Value
			case "vcs.revision":
				rev = setting.Value
			case "vcs.time":
				versionInfo.dateString = setting.Value
		}
	}
	versionInfo.commit = "unknown"
	if vcs != "" {
		versionInfo.commit = vcs
	}
	if rev != "" {
		versionInfo.commit += " [" + rev + "]"
	}
	// attempt to parse the date, which comes as a string in RFC3339 format, into a date.Time:
	versionInfo.date, _ = time.Parse(versionInfo.dateString, time.RFC3339)
	// we can safely ignore the parsing error: either the conversion works, or it doesn't, and we
	// cannot do anything about it... (gwyneth 20231103)

	// NOTE: I have no idea where the "builtBy" info is supposed to come from;
	// the way I do it is to force the variable with a compile-time option. (gwyneth 20231103)
	versionInfo.builtBy = TheBuilder

	return nil
}

// Internal settings, to be filled by LoadSettings().
// NOTE: This might become utterly different if we implement settings stored via
// the github.com/urfave/cli-altsrc package. (gwyneth 20231103)
type Setting struct {
	AuthKey    string `json:"-"`
	SourceLang string `json:"source_lang"`
	TargetLang string `json:"target_lang"`
	IsPro      bool   `json:"-"`
}

// Open the settings file, or, if it doesn't exist, create it first.
// TODO: Probably change all this to use github.com/urfave/cli-altsrc instead.
func LoadSettings(setting Setting, automake bool) (Setting, error) {
	if setting.AuthKey == "" {
		return setting, fmt.Errorf("no DeepL token is set; use the environment variable `DEEPL_TOKEN` to set it")
	}

	if setting.TargetLang == "" || setting.SourceLang == "" {
		homeDir, err := os.UserHomeDir()
		configPath := filepath.Join(homeDir, ".config", "deepl-translate-cli", "setting.json")
		// if either is not set, load file.
		if err != nil {
			return setting, err
		}

		bytes, err := os.ReadFile(configPath)
		if err != nil {
			errStr := fmt.Errorf("settings file does not exist. %s\n\tIt was autogenerated, please edit it to reflect your preferences", configPath)
			if automake {
				err := InitializeConfigFile(configPath)
				if err != nil {
					return setting, err
				}
			}
			return setting, errStr
		}
		if err := json.Unmarshal(bytes, &setting); err != nil {
			return setting, fmt.Errorf("%s (occurred while loading `setting.json`)", err.Error())
		}
		if setting.SourceLang == "FILLIN" || setting.TargetLang == "FILLIN" {
			return setting, fmt.Errorf("did write config file? (%s)", configPath)
		}
	}
	if setting.SourceLang == setting.TargetLang {
		return setting, fmt.Errorf("cannot have identical source lang(%s) and target lang(%s)", setting.SourceLang, setting.TargetLang)
	}
	return setting, nil
}

// Attempts to create the directory for the configuration file, with a minimalist configurztion if successful.
// If creating the directory (or the file within) fails, then abort and return error.
func InitializeConfigFile(ConfigPath string) error {
	if err := os.MkdirAll(filepath.Dir(ConfigPath), 0755); err != nil {
		return err
	}

	initSetting := Setting{
		SourceLang: "FILLIN",
		TargetLang: "FILLIN",
	}

	out, err := os.Create(ConfigPath)
	if err != nil {
		return err
	}
	defer out.Close()

	decoded, err := json.MarshalIndent(initSetting, "", "  ")
	if err != nil {
		return err
	}

	out.Write(([]byte)(decoded))
	return nil
}

// TODO: Try to use "github.com/urfave/cli/v3" in the future...
// TODO: @urfave has his own library to deal with configuration files, cli-altsrc.
//       It's obscure and sparsely documented (see ).
//       But it's probably far more flexible than the simplistic scheme used here. (gwyneth 20231103)
func main() {
	// Set up the version/runtime/debug-related variables, and cache them:
	initVersionInfo()

	// Test if the authentication can work or not, depending if we got the token
	// set as an environment variable.
	deeplToken, ok := os.LookupEnv("DEEPL_TOKEN")
	if !ok {
		fmt.Println("Please set first your DeepL authentication key using the environment variable DEEPL_TOKEN.")
		os.Exit(1)
	}

	// Configure all settings from the very start, because we need the authkey & endpoint
	// for all other calls, not just translations.
	setting, err := LoadSettings(
		Setting{
			AuthKey: deeplToken,
		},
		true)
	if err != nil {
		fmt.Printf("cannot init settings, error was: %q\n", err)
		os.Exit(1)
	}

	app := &cli.App{
		Name:      "deepl-translate-cli",
		Usage:     "Translate sentences, using the DeepL API.",
		UsageText: "deepl-translate-cli [-s|-t][--pro] trans [--tag [xml|html]] <inputfile>\ndeepl-translate-cli usage\ndeepl-translate-cli languages [--type=[source|target]]\ndeepl-translate-cli glossary-language-pairs",
		Version: fmt.Sprintf(
			"%s (rev %s) [%s %s %s] [build at %s by %s]",
			versionInfo.version,
			versionInfo.commit,
			versionInfo.goOS,
			versionInfo.goARCH,
			versionInfo.goVersion,
			versionInfo.dateString,		// Date as string in RFC3339 notation.
			versionInfo.builtBy,		// see note at the top...
		),
		DefaultCommand: "translate",	// to avoid brealing compatibility with earlier versions.
		EnableBashCompletion: true,
		Compiled: versionInfo.date,		// Converted from RFC333
		Authors: []*cli.Author{
			{
				Name: "Omochice",
				Email: "somewhere@here.jp",
			},
			{
				Name: "Gwyneth Llewelyn",
				Email: "gwyneth.llewelyn@gwynethllewelyn.net",
			},
		},
		Copyright: "Â© 2021-2023 by Omochice. All rights reserved. Freely distributed under a MIT license.\nThis software is not affiliated nor endorsed by DeepL SE.",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "source_lang",
				Aliases: []string{"s"},
				Usage:   "Set source language without using the settings file",
				Value:	 "EN",
			},
			&cli.StringFlag{
				Name:    "target_lang",
				Aliases: []string{"t"},
				Usage:   "Set target language without using the settings file",
				Value:	 "JA",
			},
			&cli.BoolFlag{
				Name:    "pro",
				Usage:   "Use Pro plan's endpoint?",
				Value:   false,
			},
		},
		Commands: []*cli.Command{
			{
				Name:        "translate",
				Aliases:     []string{"trans"},
				Usage:       "Basic translation of a set of Unicode strings into another language",
				Description: "Text to be translated. Only UTF-8-encoded plain text is supported. The parameter may be specified multiple times and translations are returned in the same order as they are requested. Each of the parameter values may contain multiple sentences. Up to 50 texts can be sent for translation in one request.",
				Category:	 "Translations",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "tag_handling",
						Usage:       "Set to XML or HTML in order to do more advanced parsing (empty means just using the plain text variant)",
						Aliases:     []string{"tag"},
						Value:       "",
					},
				},
				Action: func(c *cli.Context) error {
					if c.String("source_lang") != "" {
						setting.SourceLang = c.String("source_lang")
					}
					if c.String("target_lang") != "" {
						setting.TargetLang = c.String("target_lang")
					}
					if c.Bool("pro") {
						setting.IsPro = true
					}
					var rawSentence string
					if c.NArg() == 0 {
						// no filename path passed; read from STDIN (TTY or pipe)
						if isatty.IsTerminal(os.Stdin.Fd()) {
							// is not pipe (i.e. TTY)
							// NOTE: This seems not to work very well...(gwyneth 20231101)
							fmt.Scan(&rawSentence)
						} else {
							// is pipe
							pipeIn, err := io.ReadAll(os.Stdin)
							if err != nil {
								return err
							}
							rawSentence = string(pipeIn)
						}
					} else {
						if c.NArg() >= 2 {
							return fmt.Errorf("cannot specify multiple file paths")
						}
						f, err := os.Open(c.Args().First())
						if err != nil {
							return err
						}
						b, err := io.ReadAll(f)
						if err != nil {
							return err
						}
						rawSentence = string(b)
					}

					client := deepl.DeepLClient{
						Endpoint: deepl.GetEndpoint(c.Bool("pro")) + "/translate",
						AuthKey:  setting.AuthKey,
					}

					if c.String("tag_handling") == "" {
						translateds, err := client.Translate(rawSentence, setting.SourceLang, setting.TargetLang)
						if err != nil {
							return err
						}
						for _, translated := range translateds {
							fmt.Print(translated)
						}
						return nil
					}
					return fmt.Errorf("tag_handling not implemented yet")
				},
			},
			{
				Name:        "usage",
				Aliases:     []string{"u"},
				Usage:       "Check usage and limits",
				Description: "Retrieve usage information within the current billing period together with the corresponding account limits.",
				Category:	 "Utilities",
				Action: func(c *cli.Context) error {
					client := deepl.DeepLClient{
						Endpoint: deepl.GetEndpoint(c.Bool("pro")) + "/usage",
						AuthKey:  setting.AuthKey,
					}
					s, err := client.Usage()
					if err != nil {
						return err
					}
					fmt.Println(s)
					return nil
				},
			},
			{
				Name:        "languages",
				// Aliases:     []string{"l"},
				Usage:       "Retrieve supported languages",
				Description: "Retrieve the list of languages that are currently supported for translation, either as source or target language, respectively.",
				Category:	 "Utilities",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "type",
						Usage:       "`TYPE` sets whether source or target languages should be listed. Possible options are:\n`source`: For languages that can be used in the `source_lang` parameter of translate requests.\n`target`: For languages that can be used in the `target_lang` parameter of translate requests.\n",
						Value:       "source",
						DefaultText: "source",
						Action: func(c *cli.Context, v string) error {
							switch v {
								case "source":
									fallthrough
								case "target":
									return nil
								default:
									return fmt.Errorf("type must be either `source` or `target` (got: %s)", v)
							}
						},
					},
				},
				Action: func(c *cli.Context) error {
					client := deepl.DeepLClient{
						Endpoint:		deepl.GetEndpoint(c.Bool("pro")) + "/languages",
						AuthKey:  		setting.AuthKey,
						LanguagesType:	c.String("type"),
					}
					s, err := client.Languages()
					if err != nil {
						return err
					}
					fmt.Println(s)
					return nil
				},
			},
			{
				Name:        "glossary-language-pairs",
				// Aliases:     []string{"l"},
				Usage:       "List language pairs supported by glossaries",
				Description: "Retrieve the list of language pairs supported by the glossary feature.",
				Category:	 "Glossary",
				Action: func(c *cli.Context) error {
					client := deepl.DeepLClient{
						Endpoint:		deepl.GetEndpoint(c.Bool("pro")) + "/glossary-language-pairs",
						AuthKey:  		setting.AuthKey,
					}
					s, err := client.GlossaryLanguagePairs()
					if err != nil {
						return err
					}
					fmt.Println(s)
					return nil
				},
			},
		},
	}
	err = app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
